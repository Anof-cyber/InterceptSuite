using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.IO;
using System.Net;
using System.Net.NetworkInformation;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Threading;
using Microsoft.Win32;

namespace TLS_MITM_WPF;

public partial class MainWindow : Window, INotifyPropertyChanged
{
    // Data models
    public class LogEvent : INotifyPropertyChanged
    {
        private string _timestamp = "";
        private string _sourceIp = "";
        private string _destinationIp = "";
        private int _port;
        private string _type = "";
        private string _data = "";

        public string Timestamp
        {
            get => _timestamp;
            set { _timestamp = value; OnPropertyChanged(nameof(Timestamp)); }
        }

        public string SourceIp
        {
            get => _sourceIp;
            set { _sourceIp = value; OnPropertyChanged(nameof(SourceIp)); }
        }

        public string DestinationIp
        {
            get => _destinationIp;
            set { _destinationIp = value; OnPropertyChanged(nameof(DestinationIp)); }
        }

        public int Port
        {
            get => _port;
            set { _port = value; OnPropertyChanged(nameof(Port)); }
        }

        public string Type
        {
            get => _type;
            set { _type = value; OnPropertyChanged(nameof(Type)); }
        }

        public string Data
        {
            get => _data;
            set { _data = value; OnPropertyChanged(nameof(Data)); }
        }

        public event PropertyChangedEventHandler? PropertyChanged;
        protected virtual void OnPropertyChanged(string propertyName) =>
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }

    public class ConnectionEvent : INotifyPropertyChanged
    {
        private string _timestamp = "";
        private string _event = "";
        private int _connectionId;
        private string _sourceIp = "";
        private int _sourcePort;
        private string _destinationIp = "";
        private int _destinationPort;
        private string _status = "";
        private DateTime _startTime;
        private long _bytesSent;
        private long _bytesReceived;

        public int Id
        {
            get => _id;
            set { _id = value; OnPropertyChanged(nameof(Id)); }
        }

        public string ClientIp
        {
            get => _clientIp;
            set { _clientIp = value; OnPropertyChanged(nameof(ClientIp)); }
        }

        public int ClientPort
        {
            get => _clientPort;
            set { _clientPort = value; OnPropertyChanged(nameof(ClientPort)); }
        }

        public string TargetHost
        {
            get => _targetHost;
            set { _targetHost = value; OnPropertyChanged(nameof(TargetHost)); }
        }

        public int TargetPort
        {
            get => _targetPort;
            set { _targetPort = value; OnPropertyChanged(nameof(TargetPort)); }
        }

        public string Status
        {
            get => _status;
            set { _status = value; OnPropertyChanged(nameof(Status)); }
        }

        public DateTime StartTime
        {
            get => _startTime;
            set { _startTime = value; OnPropertyChanged(nameof(StartTime)); }
        }

        public long BytesSent
        {
            get => _bytesSent;
            set { _bytesSent = value; OnPropertyChanged(nameof(BytesSent)); }
        }

        public long BytesReceived
        {
            get => _bytesReceived;
            set { _bytesReceived = value; OnPropertyChanged(nameof(BytesReceived)); }
        }

        public event PropertyChangedEventHandler? PropertyChanged;
        protected virtual void OnPropertyChanged(string propertyName) =>
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }

    // Collections for data binding
    public ObservableCollection<LogEvent> LogEvents { get; } = new();
    public ObservableCollection<ConnectionEvent> ConnectionEvents { get; } = new();

    // Fields
    private DispatcherTimer _updateTimer;
    private bool _isDllLoaded = false;
    private bool _isProxyRunning = false;
    private IntPtr _dllHandle = IntPtr.Zero;

    // DLL Import declarations
    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr LoadLibrary(string lpFileName);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool FreeLibrary(IntPtr hModule);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);

    // Callback delegates
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void LogCallbackDelegate(int level, IntPtr message);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void ConnectionEventCallbackDelegate(int eventType, int connectionId, IntPtr clientIp, 
        int clientPort, IntPtr targetHost, int targetPort);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void ErrorCallbackDelegate(int errorCode, IntPtr message);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void DataCallbackDelegate(int connectionId, IntPtr data, int size, int direction);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void StatusCallbackDelegate(int status, IntPtr message);

    // Function delegates for DLL functions
    private delegate int InitializeProxyDelegate();
    private delegate int StartProxyDelegate(int port, IntPtr targetHost, int targetPort);
    private delegate int StopProxyDelegate();
    private delegate int SetLogLevelDelegate(int level);
    private delegate int SetCertificateDelegate(IntPtr certPath, IntPtr keyPath);
    private delegate int GetConnectionCountDelegate();
    private delegate int GetActiveConnectionsDelegate(IntPtr buffer, int bufferSize);
    private delegate int SetLogCallbackDelegate(LogCallbackDelegate callback);
    private delegate int SetConnectionEventCallbackDelegate(ConnectionEventCallbackDelegate callback);
    private delegate int SetErrorCallbackDelegate(ErrorCallbackDelegate callback);
    private delegate int SetDataCallbackDelegate(DataCallbackDelegate callback);
    private delegate int SetStatusCallbackDelegate(StatusCallbackDelegate callback);

    // Function pointers
    private InitializeProxyDelegate? _initializeProxy;
    private StartProxyDelegate? _startProxy;
    private StopProxyDelegate? _stopProxy;
    private SetLogLevelDelegate? _setLogLevel;
    private SetCertificateDelegate? _setCertificate;
    private GetConnectionCountDelegate? _getConnectionCount;
    private GetActiveConnectionsDelegate? _getActiveConnections;
    private SetLogCallbackDelegate? _setLogCallback;
    private SetConnectionEventCallbackDelegate? _setConnectionEventCallback;
    private SetErrorCallbackDelegate? _setErrorCallback;
    private SetDataCallbackDelegate? _setDataCallback;
    private SetStatusCallbackDelegate? _setStatusCallback;

    public event PropertyChangedEventHandler? PropertyChanged;
    protected virtual void OnPropertyChanged(string propertyName) =>
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));

    public MainWindow()
    {
        InitializeComponent();
        
        // Set ItemsSource for ListViews
        ConnectionsList.ItemsSource = ConnectionEvents;
        LogsList.ItemsSource = LogEvents;

        // Initialize timer for UI updates
        _updateTimer = new DispatcherTimer();
        _updateTimer.Interval = TimeSpan.FromMilliseconds(100);
        _updateTimer.Tick += UpdateTimer_Tick;
        _updateTimer.Start();

        // Load network interfaces
        LoadNetworkInterfaces();

        // Try to load DLL automatically
        _ = LoadDllAsync();
    }

    private void UpdateTimer_Tick(object? sender, EventArgs e)
    {
        if (_isDllLoaded && _isProxyRunning)
        {
            UpdateStatistics();
        }
    }

    private async Task LoadDllAsync()
    {
        await Task.Run(() =>
        {
            try
            {
                // Try to load from current directory first
                string[] possiblePaths = {
                    "tls_proxy.dll",
                    Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "tls_proxy.dll"),
                    Path.Combine(Directory.GetCurrentDirectory(), "tls_proxy.dll")
                };

                foreach (string path in possiblePaths)
                {
                    if (File.Exists(path))
                    {
                        _dllHandle = LoadLibrary(path);
                        if (_dllHandle != IntPtr.Zero)
                        {
                            LoadFunctions();
                            _isDllLoaded = true;
                            
                            Dispatcher.Invoke(() =>
                            {
                                DllStatusText.Text = "DLL: Loaded";
                                DllStatusText.Foreground = System.Windows.Media.Brushes.Green;
                                AddLogEntry("Info", $"DLL loaded successfully from: {path}");
                            });
                            
                            break;
                        }
                    }
                }

                if (!_isDllLoaded)
                {
                    Dispatcher.Invoke(() =>
                    {
                        AddLogEntry("Error", "Failed to load tls_proxy.dll");
                    });
                }
            }
            catch (Exception ex)
            {
                Dispatcher.Invoke(() =>
                {
                    AddLogEntry("Error", $"Exception loading DLL: {ex.Message}");
                });
            }
        });
    }

    private void LoadFunctions()
    {
        // Load all required functions from the DLL
        _initializeProxy = GetDllFunction<InitializeProxyDelegate>("tls_proxy_initialize");
        _startProxy = GetDllFunction<StartProxyDelegate>("tls_proxy_start");
        _stopProxy = GetDllFunction<StopProxyDelegate>("tls_proxy_stop");
        _setLogLevel = GetDllFunction<SetLogLevelDelegate>("tls_proxy_set_log_level");
        _setCertificate = GetDllFunction<SetCertificateDelegate>("tls_proxy_set_certificate");
        _getConnectionCount = GetDllFunction<GetConnectionCountDelegate>("tls_proxy_get_connection_count");
        _getActiveConnections = GetDllFunction<GetActiveConnectionsDelegate>("tls_proxy_get_active_connections");
        _setLogCallback = GetDllFunction<SetLogCallbackDelegate>("tls_proxy_set_log_callback");
        _setConnectionEventCallback = GetDllFunction<SetConnectionEventCallbackDelegate>("tls_proxy_set_connection_event_callback");
        _setErrorCallback = GetDllFunction<SetErrorCallbackDelegate>("tls_proxy_set_error_callback");
        _setDataCallback = GetDllFunction<SetDataCallbackDelegate>("tls_proxy_set_data_callback");
        _setStatusCallback = GetDllFunction<SetStatusCallbackDelegate>("tls_proxy_set_status_callback");

        // Set up callbacks
        if (_setLogCallback != null)
            _setLogCallback(OnLogMessage);
        if (_setConnectionEventCallback != null)
            _setConnectionEventCallback(OnConnectionEvent);
        if (_setErrorCallback != null)
            _setErrorCallback(OnError);
        if (_setStatusCallback != null)
            _setStatusCallback(OnStatusUpdate);

        // Initialize the proxy
        if (_initializeProxy != null)
            _initializeProxy();
    }

    private T? GetDllFunction<T>(string functionName) where T : Delegate
    {
        IntPtr functionPtr = GetProcAddress(_dllHandle, functionName);
        if (functionPtr != IntPtr.Zero)
        {
            return Marshal.GetDelegateForFunctionPointer<T>(functionPtr);
        }
        return null;
    }

    // Callback implementations
    private void OnLogMessage(int level, IntPtr message)
    {
        string msg = Marshal.PtrToStringAnsi(message) ?? "";
        string levelStr = level switch
        {
            0 => "Debug",
            1 => "Info",
            2 => "Warning",
            3 => "Error",
            _ => "Unknown"
        };

        Dispatcher.Invoke(() => AddLogEntry(levelStr, msg));
    }

    private void OnConnectionEvent(int eventType, int connectionId, IntPtr clientIp, 
        int clientPort, IntPtr targetHost, int targetPort)
    {
        string clientIpStr = Marshal.PtrToStringAnsi(clientIp) ?? "";
        string targetHostStr = Marshal.PtrToStringAnsi(targetHost) ?? "";

        Dispatcher.Invoke(() =>
        {
            if (eventType == 0) // Connection started
            {
                ConnectionEvents.Add(new ConnectionEvent
                {
                    Id = connectionId,
                    ClientIp = clientIpStr,
                    ClientPort = clientPort,
                    TargetHost = targetHostStr,
                    TargetPort = targetPort,
                    Status = "Connected",
                    StartTime = DateTime.Now
                });
            }
            else if (eventType == 1) // Connection ended
            {
                var connection = ConnectionEvents.FirstOrDefault(c => c.Id == connectionId);
                if (connection != null)
                {
                    connection.Status = "Disconnected";
                }
            }
        });
    }

    private void OnError(int errorCode, IntPtr message)
    {
        string msg = Marshal.PtrToStringAnsi(message) ?? "";
        Dispatcher.Invoke(() => AddLogEntry("Error", $"Error {errorCode}: {msg}"));
    }

    private void OnStatusUpdate(int status, IntPtr message)
    {
        string msg = Marshal.PtrToStringAnsi(message) ?? "";
        Dispatcher.Invoke(() =>
        {
            StatusText.Text = msg;
            StatusText.Foreground = status == 1 ? System.Windows.Media.Brushes.Green : System.Windows.Media.Brushes.Red;
        });
    }

    private void AddLogEntry(string level, string message)
    {
        LogEvents.Insert(0, new LogEvent
        {
            Timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"),
            Level = level,
            Message = message
        });

        // Keep only the last 1000 log entries
        while (LogEvents.Count > 1000)
        {
            LogEvents.RemoveAt(LogEvents.Count - 1);
        }
    }

    private void UpdateStatistics()
    {
        if (_getConnectionCount != null)
        {
            int count = _getConnectionCount();
            Dispatcher.Invoke(() =>
            {
                ActiveConnectionsText.Text = count.ToString();
                TotalConnectionsText.Text = ConnectionEvents.Count.ToString();
            });
        }
    }

    private void LoadNetworkInterfaces()
    {
        try
        {
            NetworkInterfaceComboBox.Items.Clear();
            NetworkInterfaceComboBox.Items.Add("All Interfaces");

            foreach (NetworkInterface ni in NetworkInterface.GetAllNetworkInterfaces())
            {
                if (ni.OperationalStatus == OperationalStatus.Up)
                {
                    NetworkInterfaceComboBox.Items.Add($"{ni.Name} - {ni.Description}");
                }
            }

            if (NetworkInterfaceComboBox.Items.Count > 0)
            {
                NetworkInterfaceComboBox.SelectedIndex = 0;
            }
        }
        catch (Exception ex)
        {
            AddLogEntry("Error", $"Failed to load network interfaces: {ex.Message}");
        }
    }

    // Event handlers
    private void NavigationButton_Click(object sender, RoutedEventArgs e)
    {
        if (sender is Button button && button.Tag is string tag)
        {
            // Hide all panels
            ProxyControlPanel.Visibility = Visibility.Collapsed;
            ConfigurationPanel.Visibility = Visibility.Collapsed;
            ConnectionsPanel.Visibility = Visibility.Collapsed;
            LogsPanel.Visibility = Visibility.Collapsed;

            // Show selected panel
            switch (tag)
            {
                case "ProxyControl":
                    ProxyControlPanel.Visibility = Visibility.Visible;
                    break;
                case "Configuration":
                    ConfigurationPanel.Visibility = Visibility.Visible;
                    break;
                case "Connections":
                    ConnectionsPanel.Visibility = Visibility.Visible;
                    break;
                case "Logs":
                    LogsPanel.Visibility = Visibility.Visible;
                    break;
            }
        }
    }

    private void StartProxy_Click(object sender, RoutedEventArgs e)
    {
        if (!_isDllLoaded)
        {
            MessageBox.Show("DLL not loaded. Cannot start proxy.", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            return;
        }

        try
        {
            int port = int.Parse(ListenPortTextBox.Text);
            string targetHost = TargetHostTextBox.Text;
            int targetPort = int.Parse(TargetPortTextBox.Text);

            if (_startProxy != null)
            {
                IntPtr targetHostPtr = Marshal.StringToHGlobalAnsi(targetHost);
                try
                {
                    int result = _startProxy(port, targetHostPtr, targetPort);
                    if (result == 0)
                    {
                        _isProxyRunning = true;
                        StartProxyButton.IsEnabled = false;
                        StopProxyButton.IsEnabled = true;
                        StatusText.Text = "Running";
                        StatusText.Foreground = System.Windows.Media.Brushes.Green;
                        AddLogEntry("Info", $"Proxy started on port {port}, targeting {targetHost}:{targetPort}");
                    }
                    else
                    {
                        AddLogEntry("Error", $"Failed to start proxy (error code: {result})");
                    }
                }
                finally
                {
                    Marshal.FreeHGlobal(targetHostPtr);
                }
            }
        }
        catch (Exception ex)
        {
            AddLogEntry("Error", $"Exception starting proxy: {ex.Message}");
        }
    }

    private void StopProxy_Click(object sender, RoutedEventArgs e)
    {
        try
        {
            if (_stopProxy != null)
            {
                int result = _stopProxy();
                if (result == 0)
                {
                    _isProxyRunning = false;
                    StartProxyButton.IsEnabled = true;
                    StopProxyButton.IsEnabled = false;
                    StatusText.Text = "Stopped";
                    StatusText.Foreground = System.Windows.Media.Brushes.Red;
                    AddLogEntry("Info", "Proxy stopped");
                }
                else
                {
                    AddLogEntry("Error", $"Failed to stop proxy (error code: {result})");
                }
            }
        }
        catch (Exception ex)
        {
            AddLogEntry("Error", $"Exception stopping proxy: {ex.Message}");
        }
    }

    private void BrowseCertificate_Click(object sender, RoutedEventArgs e)
    {
        OpenFileDialog dialog = new OpenFileDialog
        {
            Filter = "Certificate files (*.pem;*.crt)|*.pem;*.crt|All files (*.*)|*.*",
            Title = "Select Certificate File"
        };

        if (dialog.ShowDialog() == true)
        {
            CertificatePathTextBox.Text = dialog.FileName;
        }
    }

    private void ApplySettings_Click(object sender, RoutedEventArgs e)
    {
        try
        {
            // Apply log level
            if (_setLogLevel != null && LogLevelComboBox.SelectedItem is ComboBoxItem selectedItem)
            {
                int logLevel = selectedItem.Content.ToString() switch
                {
                    "Debug" => 0,
                    "Info" => 1,
                    "Warning" => 2,
                    "Error" => 3,
                    _ => 1
                };
                _setLogLevel(logLevel);
                AddLogEntry("Info", $"Log level set to: {selectedItem.Content}");
            }

            // Apply certificate if specified
            if (!string.IsNullOrEmpty(CertificatePathTextBox.Text) && _setCertificate != null)
            {
                IntPtr certPathPtr = Marshal.StringToHGlobalAnsi(CertificatePathTextBox.Text);
                try
                {
                    _setCertificate(certPathPtr, IntPtr.Zero);
                    AddLogEntry("Info", $"Certificate set to: {CertificatePathTextBox.Text}");
                }
                finally
                {
                    Marshal.FreeHGlobal(certPathPtr);
                }
            }

            AddLogEntry("Info", "Settings applied successfully");
        }
        catch (Exception ex)
        {
            AddLogEntry("Error", $"Failed to apply settings: {ex.Message}");
        }
    }

    private void ClearLogs_Click(object sender, RoutedEventArgs e)
    {
        LogEvents.Clear();
        AddLogEntry("Info", "Logs cleared");
    }

    private void ExportLogs_Click(object sender, RoutedEventArgs e)
    {
        try
        {
            SaveFileDialog dialog = new SaveFileDialog
            {
                Filter = "Text files (*.txt)|*.txt|CSV files (*.csv)|*.csv|All files (*.*)|*.*",
                DefaultExt = ".txt",
                FileName = $"TLS_MITM_Logs_{DateTime.Now:yyyyMMdd_HHmmss}"
            };

            if (dialog.ShowDialog() == true)
            {
                using (StreamWriter writer = new StreamWriter(dialog.FileName))
                {
                    foreach (var log in LogEvents)
                    {
                        writer.WriteLine($"{log.Timestamp}\t{log.Level}\t{log.Message}");
                    }
                }
                AddLogEntry("Info", $"Logs exported to: {dialog.FileName}");
            }
        }
        catch (Exception ex)
        {
            AddLogEntry("Error", $"Failed to export logs: {ex.Message}");
        }
    }

    protected override void OnClosed(EventArgs e)
    {
        try
        {
            _updateTimer?.Stop();
            
            if (_isProxyRunning && _stopProxy != null)
            {
                _stopProxy();
            }

            if (_dllHandle != IntPtr.Zero)
            {
                FreeLibrary(_dllHandle);
            }
        }
        catch (Exception ex)
        {
            // Log error but don't prevent window from closing
            System.Diagnostics.Debug.WriteLine($"Error during cleanup: {ex.Message}");
        }
        
        base.OnClosed(e);
    }
}