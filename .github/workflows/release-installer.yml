name: Create Installer

on:
  release:
    types: [created]

permissions:
  contents: write  # Needed to create releases
  packages: read

jobs:
  build-installer:
    runs-on: windows-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Get version from tag
        id: get_version
        run: |
          $tag = "${{ github.ref }}".Replace('refs/tags/', '')
          $version = $tag.TrimStart('v')
          echo "VERSION=$version" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        shell: pwsh

      - name: Install Inno Setup
        run: |
          Invoke-WebRequest -Uri "https://files.jrsoftware.org/is/6/innosetup-6.2.1.exe" -OutFile "innosetup-installer.exe"
          Start-Process -FilePath "innosetup-installer.exe" -ArgumentList "/VERYSILENT /SUPPRESSMSGBOXES /NORESTART /SP-" -Wait
        shell: pwsh

      - name: Create installer script
        run: |
          $version = "${{ steps.get_version.outputs.VERSION }}"
          $scriptContent = @"
          #define MyAppName "InterceptSuite"
          #define MyAppVersion "$version"
          #define MyAppPublisher "Anof-cyber"
          #define MyAppURL "https://github.com/Anof-cyber/InterceptSuite"
          #define MyAppExeName "InterceptSuite.exe"
          #define RepoOwner "Anof-cyber"
          #define RepoName "InterceptSuite"

          [Setup]
          AppId={{41FF7D2A-4911-4712-9097-229C1DB8BCAE}}
          AppName={#MyAppName}
          AppVersion={#MyAppVersion}
          AppPublisher={#MyAppPublisher}
          AppPublisherURL={#MyAppURL}
          AppSupportURL={#MyAppURL}
          AppUpdatesURL={#MyAppURL}
          DefaultDirName={autopf}\{#MyAppName}
          DefaultGroupName={#MyAppName}
          OutputDir=Output
          OutputBaseFilename={#MyAppName}_Installer_v{#MyAppVersion}
          Compression=lzma
          SolidCompression=yes
          WizardStyle=modern

          [Languages]
          Name: "english"; MessagesFile: "compiler:Default.isl"

          [Tasks]
          Name: "desktopicon"; Description: "{cm:CreateDesktopIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: unchecked

          [Icons]
          Name: "{group}\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"
          Name: "{group}\{cm:UninstallProgram,{#MyAppName}}"; Filename: "{uninstallexe}"
          Name: "{autodesktop}\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"; Tasks: desktopicon

          [Code]
          // Import Windows API functions
          procedure URLDownloadToFile(
            pCaller: Integer;
            szURL: String;
            szFileName: String;
            dwReserved: Integer;
            lpfnCB: Integer
          ); external 'URLDownloadToFileA@urlmon.dll stdcall';

          function GetPowerShellPath: string;
          begin
            // Get the path to PowerShell
            if FileExists(ExpandConstant('{sys}\WindowsPowerShell\v1.0\powershell.exe')) then
              Result := ExpandConstant('{sys}\WindowsPowerShell\v1.0\powershell.exe')
            else
              Result := '';
          end;

          function CheckDotNet8: Boolean;
          var
            ResultCode: Integer;
            PowerShellPath: string;
            PowerShellArgs: string;
          begin
            // Check if .NET 8.0 is installed using PowerShell
            PowerShellPath := GetPowerShellPath();
            if PowerShellPath = '' then
            begin
              Result := False;
              Exit;
            end;

            // PowerShell command to check .NET 8.0 Runtime
            PowerShellArgs := '-NoProfile -ExecutionPolicy Bypass -Command "if (Get-Command dotnet -ErrorAction SilentlyContinue) { $versions = dotnet --list-runtimes | Where-Object { $_ -like ''Microsoft.WindowsDesktop.App 8.*'' }; if ($versions) { exit 0 } else { exit 1 } } else { exit 1 }"';

            if Exec(PowerShellPath, PowerShellArgs, '', SW_HIDE, ewWaitUntilTerminated, ResultCode) then
              Result := (ResultCode = 0)
            else
              Result := False;
          end;          function DownloadFileWithPowerShell(url, destFile: String): Boolean;
          var
            PowerShellPath: String;
            DownloadCmd: String;
            ResultCode: Integer;
          begin
            Result := False;
            PowerShellPath := GetPowerShellPath();

            if PowerShellPath = '' then
              Exit;

            // Create directory if it doesn't exist
            ForceDirectories(ExtractFileDir(destFile));

            // Use PowerShell with WebClient - better handling of redirects
            DownloadCmd := Format('-NoProfile -ExecutionPolicy Bypass -Command "try { [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12; $webClient = New-Object System.Net.WebClient; $webClient.DownloadFile(''%s'', ''%s''); if($?) { exit 0 } else { exit 1 } } catch { Write-Host $_.Exception.Message; exit 1 }"', [url, destFile]);

            if Exec(PowerShellPath, DownloadCmd, '', SW_HIDE, ewWaitUntilTerminated, ResultCode) then
            begin
              Result := (ResultCode = 0) and FileExists(destFile);
              if not Result then
              begin
                // Try alternative PowerShell download method
                DownloadCmd := Format('-NoProfile -ExecutionPolicy Bypass -Command "try { [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12; Invoke-WebRequest -Uri ''%s'' -OutFile ''%s'' -UseBasicParsing -MaximumRedirection 10; if($?) { exit 0 } else { exit 1 } } catch { Write-Host $_.Exception.Message; exit 1 }"', [url, destFile]);

                if Exec(PowerShellPath, DownloadCmd, '', SW_HIDE, ewWaitUntilTerminated, ResultCode) then
                  Result := (ResultCode = 0) and FileExists(destFile);
              end;
            end;
          end;

          function InitializeSetup(): Boolean;
          var
            ResultCode: Integer;
            DotNetURL: string;
            DotNetInstaller: string;
          begin
            Result := True;

            // Check if .NET 8.0 is installed
            if not CheckDotNet8() then
            begin
              if MsgBox('This application requires .NET 8.0 Runtime.'#13#10'Do you want to download and install it now?', mbConfirmation, MB_YESNO) = IDYES then
              begin
                // Download .NET 8.0 installer
                if not ForceDirectories(ExpandConstant('{tmp}\NetFx')) then
                begin
                  MsgBox('Error creating temporary directory for .NET 8.0 download.', mbError, MB_OK);
                  Result := False;
                  Exit;
                end;                // .NET 8.0 Desktop Runtime direct download URL
                DotNetURL := 'https://download.visualstudio.microsoft.com/download/pr/c629f243-5125-4751-a5bb-b7cfa0bd167e/65e127d75dc85558c7a18c7895a6f4af/windowsdesktop-runtime-8.0.3-win-x64.exe';
                DotNetInstaller := ExpandConstant('{tmp}\NetFx\dotnet-desktop-8.0.3-win-x64.exe');

                if not DownloadFileWithPowerShell(DotNetURL, DotNetInstaller) then
                begin
                  MsgBox('Error downloading .NET Framework.', mbError, MB_OK);
                  Result := False;
                  Exit;
                end;

                // Run the installer
                if Exec(DotNetInstaller, '/passive /norestart', '', SW_SHOW, ewWaitUntilTerminated, ResultCode) then
                begin
                  // Check installation result
                  if ResultCode = 0 then
                    Result := True
                  else
                  begin
                    MsgBox('Failed to install .NET Framework. Please install it manually and run setup again.', mbError, MB_OK);
                    Result := False;
                  end;
                end
                else
                begin
                  MsgBox('Error executing .NET Framework installer.', mbError, MB_OK);
                  Result := False;
                end;
              end
              else
              begin
                Result := False;
              end;
            end;
          end;          function DownloadAndInstallApp(): Boolean;
          var
            ZipPath: String;
            AssetUrl: String;
            PowerShellPath: String;
            ExtractCmd: String;
            CopyCmd: String;
            TempDir: String;
            ResultCode: Integer;
          begin
            Result := False;

            // Setup paths
            ZipPath := ExpandConstant('{tmp}\{#MyAppName}.zip');
            TempDir := ExpandConstant('{tmp}\{#MyAppName}_temp');

            // Create temp directory
            if not ForceDirectories(TempDir) then
            begin
              MsgBox('Could not create temporary directory: ' + TempDir, mbError, MB_OK);
              Exit;
            end;

            // Updated asset URL to match your release pattern
            AssetUrl := 'https://github.com/{#RepoOwner}/{#RepoName}/releases/download/v{#MyAppVersion}/{#MyAppName}-v{#MyAppVersion}-win-x64.zip';

            // Get PowerShell path
            PowerShellPath := GetPowerShellPath();
            if PowerShellPath = '' then
            begin
              MsgBox('PowerShell not found. Cannot download or extract files.', mbError, MB_OK);
              Exit;
            end;

            // Download the ZIP file using PowerShell for better redirect handling
            if DownloadFileWithPowerShell(AssetUrl, ZipPath) then
            begin
              // Extract using PowerShell's Expand-Archive which handles zip files better
              ExtractCmd := Format('-NoProfile -ExecutionPolicy Bypass -Command "try { Expand-Archive -Path ''%s'' -DestinationPath ''%s'' -Force; exit 0 } catch { Write-Host $_.Exception.Message; exit 1 }"', [ZipPath, TempDir]);

              if not Exec(PowerShellPath, ExtractCmd, '', SW_HIDE, ewWaitUntilTerminated, ResultCode) or (ResultCode <> 0) then
              begin
                MsgBox('Failed to extract ZIP file. Error code: ' + IntToStr(ResultCode), mbError, MB_OK);
                Exit;
              end;

              // Check if files are in a subdirectory (common with GitHub releases)
              if DirExists(TempDir + '\{#MyAppName}-v{#MyAppVersion}-win-x64') then
                TempDir := TempDir + '\{#MyAppName}-v{#MyAppVersion}-win-x64';

              // Create app directory if it doesn't exist
              if not ForceDirectories(ExpandConstant('{app}')) then
              begin
                MsgBox('Could not create application directory', mbError, MB_OK);
                Exit;
              end;

              // Copy files to the app directory
              CopyCmd := Format('-NoProfile -ExecutionPolicy Bypass -Command "try { Copy-Item -Path ''%s\*'' -Destination ''%s'' -Recurse -Force; exit 0 } catch { Write-Host $_.Exception.Message; exit 1 }"', [TempDir, ExpandConstant('{app}')]);

              if Exec(PowerShellPath, CopyCmd, '', SW_HIDE, ewWaitUntilTerminated, ResultCode) and (ResultCode = 0) then
              begin
                if FileExists(ExpandConstant('{app}\{#MyAppExeName}')) then
                  Result := True
                else
                  MsgBox('Application files copied but executable not found', mbError, MB_OK);
              end
              else
                MsgBox('Failed to copy application files', mbError, MB_OK);
            end
            else
            begin
              MsgBox('Failed to download application from: ' + AssetUrl, mbError, MB_OK);
            end;

            // Clean up
            DeleteFile(ZipPath);
            DelTree(ExpandConstant('{tmp}\{#MyAppName}_temp'), True, True, True);
          end;          procedure CurStepChanged(CurStep: TSetupStep);
          begin
            if CurStep = ssPostInstall then
            begin
              WizardForm.StatusLabel.Caption := 'Downloading InterceptSuite application...';
              WizardForm.ProgressGauge.Style := npbstMarquee;

              if not DownloadAndInstallApp() then
              begin
                MsgBox('Failed to download and install the application. Please check your internet connection and try again.' + #13#10 +
                       'You can also manually download from: https://github.com/{#RepoOwner}/{#RepoName}/releases', mbError, MB_OK);
              end
              else
              begin
                WizardForm.StatusLabel.Caption := 'Installation completed successfully!';
              end;

              WizardForm.ProgressGauge.Style := npbstNormal;
            end;
          end;
          "@

          New-Item -ItemType Directory -Path "installer-script" -Force
          Set-Content -Path "installer-script\setup.iss" -Value $scriptContent
          New-Item -ItemType Directory -Path "Output" -Force
        shell: pwsh

      - name: Build Installer
        run: |
          & "C:\Program Files (x86)\Inno Setup 6\ISCC.exe" "installer-script\setup.iss"
        shell: pwsh

      - name: Upload installer to release
        uses: softprops/action-gh-release@v2
        with:
          files: installer-script/Output/InterceptSuite_Installer_v${{ steps.get_version.outputs.VERSION }}.exe